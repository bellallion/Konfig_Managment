# Домашние задания по конфигурационному управлению
## Описание 
В данном репозитории расположены выполненные домашние задания по дисциплине "Конфигурационное управление" 
## Задание 1
### Описание
Эмулятор для языка оболочки ОС, похожий на сеанс на сеанс shell в UNIX-подобной ОС. Он должен запускаться из реальной командной строки, а файл с
виртуальной файловой системой не нужно распаковывать у пользователя. 
Эмулятор принимает образ виртуальной файловой системы в виде файла формата
tar. Эмулятор должен работать в режиме CLI.
Ключами командной строки задаются:
- Имя пользователя для показа в приглашении к вводу.
- Путь к архиву виртуальной файловой системы.
- Путь к стартовому скрипту.

### Структура программы
- main.py — содержит класс Shell, реализующий все необходимые функции, а также функции для выполнения стартового скрипта и т.п.
### Функции
- _ls() - эмуляция команды ls,
- _cd() - эмуляция команды cd
- _chown() - эмуляция команды chown
- _tail() - эмуляция команды tail
- _du() - эмуляция команды du
- execute() - эмуляция работы командной строки
- run_start_script - Исполнение стартового скрипта при запуске программы
- run_program() - запуск программы
### Демонстрация работоспособности
Ниже показаны примеры использования данной программы.
![Image alt](Task_1/Image/img_ls.png )
![Image alt](Task_1/Image/img_cd__tail_exit.png )
### Результаты тестирования
Для каждой из требуемых функций были написаны тесты. Результат их прохождения показан ниже.

![Image alt](Task_1/Image/img_tests.png )
## Задание 2
### Описание
Разработать инструмент командной строки для визуализации графа
зависимостей, включая транзитивные зависимости. Сторонние программы или
библиотеки для получения зависимостей использовать нельзя.
Зависимости определяются для файла-пакета платформы .NET (nupkg). Для
описания графа зависимостей используется представление Mermaid.
Визуализатор должен выводить результат на экран в виде кода.
Ключами командной строки задаются:
- Путь к программе для визуализации графов.
- Путь к анализируемому пакету.
- Путь к файлу-результату в виде кода.
- URL-адрес репозитория.

### Структура программы
- main.py — содержит функции для выполнения задания
### Функции
- download_package() - устанавливает пакет из указанного репозитория
- find_nuspec() - находит файл, содержащий манифест 
- get_dependencies() - извлекает и сохраняет зависимости из файла-манифеста
- build_graph() - строит граф по правилам согласно заданию
- save_result() - сохраняет результат в виде кода в указанном файле
- visualize_graph() - визуализирует граф
- main() - запуск программы
### Демонстрация работоспособности
Ниже показаны примеры использования данной программы.
Отображение графа зависимостей в виде кода:
![Image alt](Task_2/Image/result_code.png )
Визуализация графа:
![Image alt](Task_2/Image/result_graph.png )
### Результаты тестирования
Для каждой из требуемых функций были написаны тесты. Результат их прохождения показан ниже.

![Image alt](Task_2/Image/tests.png )

## Задание 3
### Описание
Разработать инструмент командной строки для учебного конфигурационного
языка, синтаксис которого приведен далее. Этот инструмент преобразует текст из
входного формата в выходной. Синтаксические ошибки выявляются с выдачей
сообщений.
Входной текст на учебном конфигурационном языке принимается из
стандартного ввода. Выходной текст на языке json попадает в стандартный
вывод.
- Однострочные комментарии:
\ Это однострочный комментарий
- Массивы:
'( значение значение значение ... )
- Словари:
{
 имя = значение;
 имя = значение;
 имя = значение;
 ...
}
- Имена:
[A-Z]+
- Значения:
  1. Числа.
  2. Строки.
  3. Массивы.
  4. Словари.
- Строки:
"Это строка"
- Объявление константы на этапе трансляции:
let имя = значение;
- Вычисление константы на этапе трансляции:
.[имя].
Результатом вычисления константного выражения является значение.
Все конструкции учебного конфигурационного языка (с учетом их
возможной вложенности) должны быть покрыты тестами. Необходимо показать 2
примера описания конфигураций из разных предметных областей.

### Структура программы
- main.py — содержит функции для выполнения задания
### Функции
- parse_text() - разбирает входящий текст
- parse_value() - разбирает входящее значение на соответствие правилам 
- calculating_constant() - вычисляет значение константы
- parse_brackets() - считает количество словарей, в которых находимся на этапе чтения.
- parse_brackets_array() - считает количество массивов, в которых находимся на этапе чтения. 
- main() - запуск программы, чтение и вывод с помощью стандартного потока
### Демонстрация работоспособности
Ниже показаны примеры описания конфигураций из разных предметных областей.
Тест 1:
![Image alt](Task_3/Image/result_test_1.png)

Тест 2:

![Image alt](Task_3/Image/result_test_2.png )
### Результаты тестирования
Для каждой из требуемых функций были написаны тесты. Результат их прохождения показан ниже.

![Image alt](Task_3/Image/tests.png )